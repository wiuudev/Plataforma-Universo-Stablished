let a1 = ""; export function call1(o) { if (null == o) throw Error("arg of cacl1 is not defined"); a1 += o, console.log(o) } export function call2(o) { if (null == o) throw Error("arg of cacl2 is not defined"); a1 += o, console.log(o) } export function show() { console.log(a1) } export function consoleLog(o) { console.log(o) } import { _addPoint as o, _addPointTooltip as e, _addPointCustomSymbology as t, _addPointCustomSymbologyAndTooltip as l, _addPointIcon as n, _addPointIconAndTooltip as a, _addPointFromArrayToMap as r, _deleteAllPointsFromArray as i, _setPointFromArrayCurrentSymbol as s, _addLabelPointFromArrayToMap as p, _deleteAllLabels as c } from "./geometry/point.js"; import { _initializationOfRendering as d, _settingsOfRendering as m, _resetOfRendering as u, _emptyStreamPointCollection as g, _addPointToCollection as f, _addPointsToCollection as x, _addPointsOnType as C, _clearAllPointsCollection as y, _clearPointsByIdsCollection as M, _movePointFromCollection as h, _pointsLayersGroup as v } from "./geometry/points.js"; import { _addPolygonsArrayToMap as $, _setCurrentSymbol as A } from "./geometry/polygons.js"; import { _addMeasureArrayToMap as P, _addMeasureText as b, _addMeasureStyle as k, _addMeasureAnchor as E, _deleteAll as T } from "./geometry/polylines.js"; import { initBasemapLayers as O } from "./layers/basemap.js"; import { _setGeometricLayersVisibilityScale as w } from "./layers/geometricLayers.js"; let map = null, layers_control = null, LeafletCore = null, config = { api: { src: "https://unpkg.com/leaflet@1.9.3/dist/leaflet.js", href: "https://unpkg.com/leaflet@1.9.3/dist/leaflet.css" } }; export const MapCoreInitialization = (o, e) => { let t = document.createElement("script"); t.src = config.api.src, t.async = !0; let l = document.createElement("link"); l.href = config.api.href, l.rel = "stylesheet", document.body.appendChild(l), document.body.appendChild(t); let n = void 0 === e ? 0 : void 0 === e.location || null === e.location ? 0 : void 0 === e.location.longitude ? 0 : e.location.longitude, a = void 0 === e ? 0 : void 0 === e.location || null === e.location ? 0 : void 0 === e.location.latitude ? 0 : e.location.latitude; t.onload = () => { LeafletCore = L, null !== (layers_control = _layers_control(map = L.map(e.__mapid, { doubleClickZoom: !0, shiftBoxZoom: !0, dragging: !0 }).on("load", function (e) { let t = e.target, l = t.getBounds(); o.invokeMethodAsync("onAfterMapLoaded", { zoomLevel: t._zoom, centerOfView: { latitude: t._lastCenter.lat, longitude: t._lastCenter.lng }, bounds: { northEast: { latitude: l._northEast.lat, longitude: l._northEast.lng }, southWest: { latitude: l._southWest.lat, longitude: l._southWest.lng } } }) }).setView({ lon: n, lat: a }, e.zoom_level))) && O(map, !1, e.basemap, layers_control), null !== e.map_scale && void 0 !== e.map_scale.has && !0 === e.map_scale.has && L.control.scale({ metric: e.map_scale.meters, imperial: e.map_scale.miles }).addTo(map), _setOnClickMapEvent(o), _setOnDoubleClickMapEvent(o), _setOnMouseDownMapEvent(o), _setOnMouseUpMapEvent(o) }, t.onerror = () => { console.warn("Error occurred while loading Leaflet script") } }; export const _setOnClickMapEvent = o => { map.on("click", e => { o.invokeMethodAsync("onClickingMap", { location: { latitude: e.latlng.lat, longitude: e.latlng.lng } }) }) }; export const _setOnDoubleClickMapEvent = o => { map.on("dblclick", e => { o.invokeMethodAsync("onDoubleClickingMap", { location: { latitude: e.latlng.lat, longitude: e.latlng.lng } }) }) }; export const _setOnMouseDownMapEvent = o => { map.on("mousedown", e => { o.invokeMethodAsync("onMouseDownMap", { location: { latitude: e.latlng.lat, longitude: e.latlng.lng } }) }) }; export const _setOnMouseUpMapEvent = o => { map.on("mouseup", e => { o.invokeMethodAsync("onMouseUpMap", { location: { latitude: e.latlng.lat, longitude: e.latlng.lng } }) }) }; let _layers_control = o => L.control.layers(null, null, { collapsed: !0 }).addTo(o); export const setGeometricLayersVisibilityScale = o => { w(v, o, map, LeafletCore) }; export const addPoint = e => { o(e, map, LeafletCore) }; export const addPointTooltip = o => { e(o, map, LeafletCore) }; export const addPointCustomSymbology = o => { t(o, map, LeafletCore) }; export const addPointCustomSymbologyAndTooltip = o => { l(o, map, LeafletCore) }; export const addPointIcon = o => { n(o, map, LeafletCore) }; export const addPointIconAndTooltip = o => { addPointIconAndTooltip(o, map, LeafletCore) }; export const addPointFromArrayToMap = o => { r(o, map, LeafletCore) }; export const deleteAllPointsFromArray = () => { i(map, LeafletCore) }; export const setPointFromArrayCurrentSymbol = o => { s(o) }; export const addLabelPointFromArrayToMap = o => { p(o, map, LeafletCore) }; export const deleteAllLabels = () => { c(map) }; export const initializationOfRendering = o => { d(o) }; export const settingsOfRendering = o => { m(o) }; export const resetOfRendering = () => { u() }; export const addPointToStreamCollection = o => { f(o, map, LeafletCore) }; export const addPointsToStreamCollection = o => x(o, !1, map, LeafletCore).length; export const addNewPointsToStreamCollection = o => { x(o, !0, map, LeafletCore) }; export const addPointsOnType = o => { C(o, !1, map, LeafletCore) }; export const addNewCollectionPointsOnType = o => { C(o, !0, map, LeafletCore) }; export const emptyStreamPointCollection = () => { g() }; export const addPolygonsArrayToMap = o => { $(o, map, LeafletCore) }; export const setCurrentSymbol = o => { A(o) }; export const addMeasureText = o => { b(o) }; export const addMeasureStyle = o => { k(o) }; export const addMeasureAnchor = o => { E(o) }; export const deleteAll = () => { T(map) }; export const addMeasureLineFromArray = o => { P(o, map, LeafletCore) }; export const clearAllStreamCollection = () => { y(map) }; export const clearPointsByIdsStreamCollection = o => { M(o, map) }; export const movePointFromStreamCollection = o => { h(o, map, LeafletCore) }; export const setExtent = o => { let e = LeafletCore.latLng(o.latmin, o.lngmin), t = LeafletCore.latLng(o.latmax, o.lngmax), l = L.latLngBounds(e, t); map.fitBounds(l) };